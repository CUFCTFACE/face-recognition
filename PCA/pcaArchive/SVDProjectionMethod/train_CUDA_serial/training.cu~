#include "main.h"

int main()
{
culaStatus s;

s = culaInitialize();
if(s != culaNoError)
{
    printf("%s\n", culaGetErrorString(s));
    /* ... Error Handling ... */
}

/* ... Your code ... */

culaShutdown();
return 0;
/*
	int i, j, k;
	char file_path[] = "../Image/Train/ORL_200/";
	char full_path[100];
	int width, height;
	PPMImage 	*testimage;
	gsl_matrix *a, *b, *eigenvector, *c, *eigenvector_thr;	
	gsl_vector *mean, *eigenvalue, *eigenvalue_thr, *image_assignment;
	gsl_eigen_symmv_workspace *w;
	
	//get size of image
	sprintf(full_path, "%s%d.ppm", file_path, 1);
	testimage = ppm_image_constructor(full_path);
	width = testimage->width;
	height = testimage->height;
	ppm_image_destructor(testimage, 1);

	a = gsl_matrix_alloc (width*height,(number_copies)*existing_images);
	b = gsl_matrix_alloc ((number_copies)*existing_images, (number_copies)*existing_images);
	gsl_matrix_set_zero(b);
	eigenvector = gsl_matrix_alloc ((number_copies)*existing_images, (number_copies)*existing_images);
	eigenvalue = gsl_vector_alloc((number_copies)*existing_images);
	w = gsl_eigen_symmv_alloc((number_copies)*existing_images);
	mean = gsl_vector_alloc (width*height);
	eigenvalue_thr = gsl_vector_alloc((number_copies)*existing_images);
	gsl_vector_set_zero (eigenvalue_thr);
	gsl_vector_set_zero (mean);

	for(i = 0; i < number_copies; i++)
	{
		for(j = 0; j < existing_images; j++)
		{
			sprintf(full_path, "%s%d.ppm", file_path, j+1);
			testimage = ppm_image_constructor(full_path);
			//copy image into the first matrix
			for(k = 0; k < width*height; k++)
			{
				//gsl_matrix_set (a, k, (i+1)*j, testimage->pixels[k].r);
				a->data[a->tda * k + (i+1)*j] = testimage->pixels[k].r;
				//printf("%d\n", k);
				mean->data[k] += testimage->pixels[k].r;
			}
			ppm_image_destructor(testimage, 1);			
		}
	}
	//for(i=0;i<10;i++)
	//printf("%f\n", a->data[i*number_copies*existing_images]);
	printf("Images loaded...\n");
	fflush(stdout);
	for(i = 0; i < width*height; i++)
	{
		mean->data[i] /= existing_images*number_copies;
	}
	//subtract the mean from the elements of matrix a
	for(i = 0; i < number_copies*existing_images; i++)
	{
		for(j = 0; j < width*height; j++)
		{
			//gsl_matrix_set (a, j, i, gsl_matrix_get(a, j,i) - mean->data[j]);//testimage->pixels[k].r);
			a->data[j*a->tda + i] -= mean->data[j];
		}
	}
	printf("Mean subtracted, images database normalized...\n");
	fflush(stdout);
//	for(i=0;i<10;i++)
//		printf("%f\n", a->data[i*number_copies*existing_images+1]);
//return 0;
	//find covariance matrix "b"
	gsl_blas_dgemm (CblasTrans, CblasNoTrans,1.0, a, a, 0.0, b);
//	for(i=0;i<100;i++)
//		printf("%f\n", b->data[i]);
//	return 0;
	//find eigenvector and eigenvalues
	gsl_eigen_symmv (b, eigenvalue, eigenvector, w);
	k=0;
	for(i=0;i<eigenvalue->size;i++)
	{
		if(eigenvalue->data[i] > 1)
		{
			eigenvalue_thr->data[i] = 1;
			k++;
		}
	}
	printf("%d\n", k);

	eigenvector_thr = gsl_matrix_alloc(eigenvalue->size, k);
	j=0;
	for(i=0;i<eigenvalue->size;i++)
	{
		if(eigenvalue_thr->data[i] == 1)
		{
			eigenvector_thr->data[i*k+j] = eigenvalue->data[i];
			j++;
		}
	}
	
	c = gsl_matrix_alloc (a->size1,k);

	printf("%d, %d, %d, %d\n", a->size1, a->size2, eigenvector_thr->size1, eigenvector_thr->size2);
	gsl_blas_dgemm (CblasNoTrans, CblasNoTrans,1.0, a, eigenvector_thr, 0.0, c);
	
	for(i=0;i<100;i++)
	printf("%f\n", c->data[i]);
	return 0;
*/
}
